[{"categories":["Gnome Builder"],"content":"Configuration of Beautifier plugins If you installed the gnome builder with Beautifier plugins (default). You will find it’s not support c++, since we have no config file for c++ language. ","date":"2020-11-09","objectID":"/posts/gnome-builder-beautifier/:0:1","tags":null,"title":"Gnome Builder Beautifier","uri":"/posts/gnome-builder-beautifier/"},{"categories":["Gnome Builder"],"content":"Reference uncrusify: https://github.com/uncrustify/uncrustify full configration of uncrusify: http://uncrustify.sourceforge.net/config.txt ","date":"2020-11-09","objectID":"/posts/gnome-builder-beautifier/:0:2","tags":null,"title":"Gnome Builder Beautifier","uri":"/posts/gnome-builder-beautifier/"},{"categories":null,"content":"前言 以下内容记录我学习pwn的过程，通过NTUSTISC的教学视频[1]来学习pwn基础知识，后续会分为几个部分一直写下去。 需要具备的基础知识： C语言 汇编语言 会用到的工具： readelf objdump PEDA pwntools 如果你看过《程序员的自我修养——链接、装载与库》，应该对前两个工具不会感到陌生。即便真的没有接触过也没关系，照葫芦画瓢也是可以的。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:1:0","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"Pwntools，使用示例 使用python 3.x。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:2:0","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"常用的函数 函数 功能 p64(int) 0xfaceb00c =\u003e b’\\x0c\\xb0\\xce\\xfa\\x00\\x00\\x00\\x00’ u64(str) b’\\x0c\\xb0\\xce\\xfa\\x00\\x00\\x00\\x00’ =\u003e 4207849484 p32(int) 0xfaceb00c =\u003e b’\\x0c\\xb0\\xce\\xfa’ u32(str) b’\\x0c\\xb0\\xce\\xfa’ =\u003e 4207849484 remote(host, port) / process(path) 与本地或远程的程序建立连接 .recv(int) 接收指定数量的字符 .recvuntil(str) 接收指定字符串以及它前面的内容 .recvline() 与.recvuntil('\\n’)作用一样 .send(str) 将指定字符串作为程序的输入 .sendline(str) 在指定字符串后加上’\\n'并作为程序的输入 .interactive() 开启交互模式 这里需要注意，用于接收的函数，返回值是byte []类型的。 下面用pwntools来做一个小练习，下面这段代码的目的是要求在90秒内完成1000到数学题目，很明显靠手工交互的模式，几乎是不可能做到的。 但是通过pwntools编写自动化脚本来完成它，却是很简单的一件事情。 #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003csignal.h\u003e#include \u003ctime.h\u003e#include \u003cunistd.h\u003e void handler(int signum){ puts(\"Timeout\"); _exit(1); } int main() { setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 2, 0); signal(SIGALRM, handler); alarm(90); unsigned seed = (unsigned)time(NULL); srand(seed); unsigned int magic; printf(\"Give me the magic number :)\\n\"); read(0, \u0026magic, 4); if (magic != 3735928559) { printf(\"Bye~\\n\"); exit(0); } printf(\"Complete 1000 math questions in 90 seconds!!!\\n\"); for (int i = 0; i \u003c 1000; ++i) { int a = random() % 65535; int b = random() % 65535; int c = random() % 3; int ans; switch(c) { case 0: printf(\"%d + %d = ?\", a, b); scanf(\"%d\", \u0026ans); if (ans != a + b) { printf(\"Bye Bye~\\n\"); exit(0); } break; case 1: printf(\"%d - %d = ?\", a, b); scanf(\"%d\", \u0026ans); if (ans != a - b) { printf(\"Bye Bye~\\n\"); exit(0); } break; case 2: printf(\"%d * %d = ?\", a, b); scanf(\"%d\", \u0026ans); if (ans != a * b) { printf(\"Bye Bye~\\n\"); exit(0); } break; } } printf(\"Good job!\\n\"); system(\"sh\"); return 0; } 先分析一下这个程序的功能，它需要我们先输入一个指定的magic number才会进入下一步，接着就是随机生成一道数学题并要我们提供正确答案。把上面的代码保存为pwntools.c并编译， gcc pwntools.c -o pwntools 解答脚本如下， from pwn import * r = process('./pwntools') p = p32(0xdeadbeef) r.recvuntil('number :)\\n') r.send(p) r.recvline() for i in range(1000): q = r.recvuntil(' = ?') # 返回的是byte []，需要转换为字符串 q = str(q) q = q.replace(' = ?', '').replace(\"'\", '').replace('b', '') print(q, end='') if '+' in q: a, b = q.split('+') ans = int(a.strip())+int(b.strip()) elif '-' in q: a, b = q.split('-') ans = int(a.strip())-int(b.strip()) elif '*' in q: a, b = q.split('*') ans = int(a.strip())*int(b.strip()) print(f\" = {ans}\") r.sendline(str(ans)) r.interactive() ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:2:1","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"x64汇编，参数传递规则 首先，要知道函数所需的参数是由调用者提前放入寄存器或栈中的。 一般情况下，当函数所需的参数个数小于6个时，通过 rdi, rsi, rdx, rcx, r8, r9 来传递参数。 若为系统调用，通过 rdi, rsi, rdx, r10, r8, r9 来传递参数。 当参数超过6个时，通过栈来传递。返回值则通过rax返回。 至于参数的传递顺序，从左往右或从右往左，不同的调用标准会有一些差异。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:3:0","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"Example 有一个add函数，调用形式如下： add(1, 2, 3, 4, 5, 6, 7) 对应的汇编代码，可能如下： 401150: 6a 07 push 0x7 401152: 41 b9 06 00 00 00 mov r9d,0x6 401158: 41 b8 05 00 00 00 mov r8d,0x5 40115e: b9 04 00 00 00 mov ecx,0x4 401163: ba 03 00 00 00 mov edx,0x3 401168: be 02 00 00 00 mov esi,0x2 40116d: bf 01 00 00 00 mov edi,0x1 401172: e8 8f ff ff ff call 401106 \u003cadd\u003e 其中r9d, r8d, ecx, edx, esi, edi是指r9, r8, rcx, rdx, rsi, rdi的低后半部分，因为x64下寄存器的大小为64位，这里只是用了低32位。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:3:1","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"Stack Frame 什么是stack frame？这里先不解释，看完后面的内容自然就清楚了。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:4:0","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"Function Prologue Prologue，本意是指序幕或者戏剧节目中的开场白。 那Function Prologue的意思可以理解为，在开始执行一个函数需要进行的一些准备工作。 以汇编语言的视角来看函数的调用（通过call指令），在执行函数的代码之前，需要完成一些准备工作。譬如：保存返回地址 （call的下一条指令的地址）、创建新的stack frame和传递参数（通过寄存器或栈）。 下面来看一般情况下，上述步骤是怎么实现的。假设当前栈、指令和寄存器的状态如下，程序将会从main函数跳转到addtwo函数： [------------------------------registers-------------------------------] RBP: 0x7fffffffdda0 RSP: 0x7fffffffdd90 RIP: 0x401141 [---------------------------------code---------------------------------] 0x401106 \u003caddtwo\u003e: push rbp 0x401107 \u003caddtwo+1\u003e: mov rbp,rsp 0x40110a \u003caddtwo+4\u003e: mov DWORD PTR [rbp-0x4],edi 0x40110d \u003caddtwo+7\u003e: mov DWORD PTR [rbp-0x8],esi 0x401110 \u003caddtwo+10\u003e: mov edx,DWORD PTR [rbp-0x4] ... =\u003e 0x401141 \u003cmain+39\u003e: call 0x401106 [--------------------------------stack---------------------------------] 0000| 0x7fffffffdd90 --\u003e 0x7fffffffdea8 \u003c-- RSP 0008| 0x7fffffffdd98 --\u003e 0x100401020 0016| 0x7fffffffdda0 --\u003e 0x7fffffffdea0 \u003c-- RBP [----------------------------------------------------------------------] 现在停在了call 0x401106，call指令执行后，会先将其下一条指令的地址让如当前栈中，如下： [------------------------------registers-------------------------------] RBP: 0x7fffffffdda0 RSP: 0x7fffffffdd88 RIP: 0x401106 [---------------------------------code---------------------------------] =\u003e 0x401106 \u003caddtwo\u003e: push rbp 0x401107 \u003caddtwo+1\u003e: mov rbp,rsp 0x40110a \u003caddtwo+4\u003e: mov DWORD PTR [rbp-0x4],edi 0x40110d \u003caddtwo+7\u003e: mov DWORD PTR [rbp-0x8],esi 0x401110 \u003caddtwo+10\u003e: mov edx,DWORD PTR [rbp-0x4] ... 0x401141 \u003cmain+39\u003e: call 0x401106 [--------------------------------stack---------------------------------] 0000| 0x7fffffffdd88 --\u003e 0x401146 \u003c-- RSP 0008| 0x7fffffffdd90 --\u003e 0x7fffffffdea8 0016| 0x7fffffffdd98 --\u003e 0x100401020 0024| 0x7fffffffdda0 --\u003e 0x7fffffffdea0 \u003c-- RBP [----------------------------------------------------------------------] 目前为止，一个新的stack frame开始创建了，它归属与被调用者addtwo。 进入addtwo函数后，前两行汇编指令的作用是保存之前的栈基址，并开启一个新的stack frame。 紧跟之后的两行是分配局部变量的空间，各占了4个字节。 edi和esi是传递给addtwo函数的两个参数（通过寄存器）。 [------------------------------registers-------------------------------] RBP: 0x7fffffffdd80 RSP: 0x7fffffffdd80 RIP: 0x401116 [---------------------------------code---------------------------------] 0x401106 \u003caddtwo\u003e: push rbp 0x401107 \u003caddtwo+1\u003e: mov rbp,rsp 0x40110a \u003caddtwo+4\u003e: mov DWORD PTR [rbp-0x4],edi 0x40110d \u003caddtwo+7\u003e: mov DWORD PTR [rbp-0x8],esi 0x401110 \u003caddtwo+10\u003e: mov edx,DWORD PTR [rbp-0x4] 0x401113 \u003caddtwo+13\u003e: mov eax,DWORD PTR [rbp-0x8] =\u003e 0x401116 \u003caddtwo+16\u003e: add eax,edx ... 0x401141 \u003cmain+39\u003e: call 0x401106 [--------------------------------stack---------------------------------] 0000| 0x7fffffffdd80 --\u003e 0x7fffffffddb0 \u003c-- RBP, RSP 0008| 0x7fffffffdd88 --\u003e 0x401146 [----------------------------------------------------------------------] 到这里Function Prologue的过程就结束了。 ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:4:1","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"Function Epilogue 了解过前面的内容，一定能够猜到Function Epilogue的意思。即，当函数准备返回时，需要进行的清理和复原工作， 如：恢复stack frame和下一条指令的执行地址。 继续前面的例子，当将要开始进行Epilogue时，内容如下： [------------------------------registers-------------------------------] RBP: 0x7fffffffdd80 RSP: 0x7fffffffdd80 RIP: 0x401118 [---------------------------------code---------------------------------] 0x401106 \u003caddtwo\u003e: push rbp 0x401107 \u003caddtwo+1\u003e: mov rbp,rsp 0x40110a \u003caddtwo+4\u003e: mov DWORD PTR [rbp-0x4],edi 0x40110d \u003caddtwo+7\u003e: mov DWORD PTR [rbp-0x8],esi 0x401110 \u003caddtwo+10\u003e: mov edx,DWORD PTR [rbp-0x4] 0x401113 \u003caddtwo+13\u003e: mov eax,DWORD PTR [rbp-0x8] 0x401116 \u003caddtwo+16\u003e: add eax,edx =\u003e 0x401118 \u003caddtwo+18\u003e: pop rbp 0x401119 \u003caddtwo+19\u003e: ret ... 0x401141 \u003cmain+39\u003e: call 0x401106 [--------------------------------stack---------------------------------] 0000| 0x7fffffffdd80 --\u003e 0x7fffffffddb0 \u003c-- RBP, RSP 0008| 0x7fffffffdd88 --\u003e 0x401146 [----------------------------------------------------------------------] Function Epilogue需要做两件事情，恢复寄存器RBP和RSP（这里的示例没有恢复RSP的内容，但过程基本一致） 并将返回地址传递给RIP（通过ret）。 所以执行玩这两条汇编指令后，结果如下： [------------------------------registers-------------------------------] RBP: 0x7fffffffddb0 RSP: 0x7fffffffdd90 RIP: 0x401138 [---------------------------------code---------------------------------] 0x401106 \u003caddtwo\u003e: push rbp 0x401107 \u003caddtwo+1\u003e: mov rbp,rsp 0x40110a \u003caddtwo+4\u003e: mov DWORD PTR [rbp-0x4],edi 0x40110d \u003caddtwo+7\u003e: mov DWORD PTR [rbp-0x8],esi 0x401110 \u003caddtwo+10\u003e: mov edx,DWORD PTR [rbp-0x4] 0x401113 \u003caddtwo+13\u003e: mov eax,DWORD PTR [rbp-0x8] 0x401116 \u003caddtwo+16\u003e: add eax,edx 0x401118 \u003caddtwo+18\u003e: pop rbp 0x401119 \u003caddtwo+19\u003e: ret ... 0x401141 \u003cmain+39\u003e: call 0x401106 =\u003e 0x401138 \u003cmain+3E\u003e: mov DWORD PTR [rbp-0x4],eax [--------------------------------stack---------------------------------] 0000| 0x7fffffffdd90 --\u003e 0x7fffffffdea8 \u003c-- RSP 0008| 0x7fffffffdd98 --\u003e 0x100401020 0016| 0x7fffffffdda0 --\u003e 0x7fffffffdea0 \u003c-- RBP [----------------------------------------------------------------------] ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:4:2","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"参考 NTUSTISC: https://www.youtube.com/channel/UC4-PD2BdlYWd807BhJZkjIg/featured ","date":"2020-11-04","objectID":"/posts/pwn-basic-part-i/:5:0","tags":null,"title":"PWN Basic Part I","uri":"/posts/pwn-basic-part-i/"},{"categories":null,"content":"前言 此处记录我安装完manjaro with gnome后进行的部分配置，和碰到的问题。下面为系统配置。 ██████████████████ ████████ *@manjaro ██████████████████ ████████ --------------- ██████████████████ ████████ OS: Manjaro Linux x86_64 ██████████████████ ████████ Host: HLY-WX9XX M1010 ████████ ████████ Kernel: 5.8.16-2-MANJARO ████████ ████████ ████████ Uptime: 52 mins ████████ ████████ ████████ Packages: 1146 (pacman) ████████ ████████ ████████ Shell: zsh 5.8 ████████ ████████ ████████ Resolution: 1920x1080 ████████ ████████ ████████ DE: GNOME 3.36.6 ████████ ████████ ████████ WM: Mutter ████████ ████████ ████████ WM Theme: Matcha-dark-aliz ████████ ████████ ████████ Theme: Prof-Gnome-Dark-3.4.1 [GTK2/3] ████████ ████████ ████████ Icons: Papirus-Dark [GTK2/3] Terminal: gnome-terminal CPU: AMD Ryzen 7 3750H with Radeon Vega Mobile Gfx (8) @ 2.300GHz GPU: AMD ATI 03:00.0 Picasso Memory: 1708MiB / 15001MiB ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:1:0","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"设置登陆界面显示在外接显示器上 由于我会将笔记本合上而只使用外接显示器，但默认情况下，gdm的登陆界面都是显示在笔记本的显示器上。 你是否希望让登陆界面默认显示在外接的显示器上呢？ 如果你有和我一样的需求，请往下看。 我使用的登陆管理器为gdm，如果你使用的是其他的登陆管理器，需要自行摸索设置方式。 参照arch文档的说明，可以通过配置文件monitors.xml来设置gdm的登陆界面显示在哪个显示器上。 先在将屏幕设置为你需要的模式，比如，mirror或者singal display。 之后执行 xrandr 会在$HOME/.config下生成一个monitors.xml文件，最后将它复制到/var/lib/gdm/.config/monitors.xml就可以了。 这样gdm就会遵循该配置来显示登陆界面。 ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:1:1","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"fcitx5 无法在部分应用中使用 装完fcitx5后，发现在firefox中无法使用。 检查之后发现，虽然我在~/.xinitrc或者~/.xprofile中设置了需要的环境变量，但是经过测试发现这两个文件中的内容都没有生效。 原因是，由于我使用的是wayland而不是xorg，这两个文件都不会被其读取。所以需要其他的方式在开启X11 Session前初始化我们的环境变量。 官网给出的方式是，通过pam_env模块來设置。将需要设置的环境变量放置在~/.pam_enviroment文件中即可。 以下为我的~/.pam_enviroment文件内容， GTK_IM_MODULE DEFAULT=fcitx QT_IM_MODULE DEFAULT=fcitx XMODIFIERS DEFAULT=\\@im=fcitx 安装fcitx5和中文输入法的命令如下， pacman -S fcitx5 fcitx5-configtool fcitx5-chinese-addons fcitx5-gtk fcitx5-qt ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:1:2","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"fcitx5 主题 推荐主题Material-Color 安装方法参照项目的README即可。 ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:1:3","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"linux-header 安装 如果你第一次安装VMware Workstation，它会提示你需要安装对应的linux-headers。 # 查找可用的linux-headers pacman -Ss linux-headers # 安装所需的linux-headers，其中XX为你所需的版本号 pacman -S linuxXX linuxXX-headers ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:1:4","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"参考 gdm: https://wiki.archlinux.org/index.php/GDM#Setup_default_monitor_settings can not type chinese: https://forum.manjaro.org/t/cannot-type-chinese-in-some-applications/31127/2 fcitx: https://wiki.archlinux.org/index.php/Fcitx#Chinese ","date":"2020-10-30","objectID":"/posts/manjaro-setup/:2:0","tags":null,"title":"Manjaro Setup","uri":"/posts/manjaro-setup/"},{"categories":null,"content":"介绍 以下记录使用vim的过程中学习到的东西（快捷键，插件，遇到的问题等）。 如果你是第一次接触vim，并想要学习如何使用它，那这个网站Interactive Vim Tutorial会是个不错的选择，你可以使用交互式的方式学习如何使用vim。 下面提及的，形如a, b的快捷键，是指先按下a，再按下b。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:1:0","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"常用命令 下面列出我常用到的命令和其作用。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:2:0","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"分屏 垂直分屏：:vsplit； 水平分屏：:split； 你可以用快捷键的方式，打开一个垂直或者水平分配的窗口。 垂直分屏：ctrl+w, v； 水平分屏：ctrl+w, s； ","date":"2020-10-20","objectID":"/posts/vim-usage/:2:1","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"控制分屏窗口大小 默认情况下，通过分屏命令弹出的窗口都是均匀划分的。你可以像下面这样调整当前窗口的大小（高和宽）， 调整高度：:resize number； 调整宽度：:vertical resize number； 也可以用递增或递减的方式来调整， 增加高度：:resize +number； 减少高度：:resize -number； 如果你觉得这样很麻烦，可以使用快捷键， 增加宽度：ctrl+w, \u003e； 增加高度：ctrl+w, +； 减少宽度：ctrl+w, \u003c； 减少高度：ctrl+w, -； 需要重置分屏窗口的大小时，使用ctrl+w, =。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:2:2","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"切换窗口 在通过:split和vsplit命令进行划分之后，需要进行窗口的切换。 可以双击ctrl + w进行轮流切换，也可以通过ctrl + w + 方向键（或者hjkl）来切换到指定的窗口。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:2:3","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"Tab 当你需要打开多个文件，而当前tab又没有多余空间使用是，你可以创建一个新的tab。 tab会以数字下标排序，显示在顶部，像下面这样, 常用的操控tab的命令如下， 创建一个新的tab：:tabnew 在tab间进行切换：gt 切换至下一个tab：:tabnext 切换至上一个tab：:tabprevious 切换至第一个tab：:tabfirst 切换至最后一个tab：:tablast 将当前tab移动到某个index：:tabmove number，number从0开始 ","date":"2020-10-20","objectID":"/posts/vim-usage/:2:4","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"拓展工具 推荐使用vimrc。 vimrc是vim的一款配置工具，安装后会自动帮你配置vim的样式，字体和各类插件。 vimrc的安装方法，见项目README。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:3:0","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"插件 vimrc帮我们集成了很多实用的插件[2]。这里列出我常用的，以及它们的使用方法。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:3:1","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"NERDtree NERD Tree可以让我们在vim中便捷的访问目录结构，在NOMAL模式下，输入:NERDTree后，会在右侧显示一个explorer。 常用的快捷键如下（需要先切换至NERDTree打开的窗口）： 刷新当前根目录：O，输入shift + o即可; 刷新当前光标所指的目录：o； 在新的tab中打开当前文件或目录：t； 在新的tab中打开当前文件或目录，但不切换过去：T； 显示隐藏文件I 如果你想让NERD Tree始终显示隐藏文件，你可以修改.vimrc文件，并在末尾加上如下内容， let NERDTreeShowHidden=1 如果你想使用vim来进行代码的编写，毫无疑问你需要一个具有代码补全功能的插件。 vim下的代码补全插件中比较优秀的有两个，一个是YouCompleteMe[5]，另一个是coc.nvim[6]。当然它们能够实现的功能远不止代码补全这么简单，个人使用的是后者，因为它可拓展，而且功能丰富。 ","date":"2020-10-20","objectID":"/posts/vim-usage/:3:2","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"参考 Resize split more quickly: https://vim.fandom.com/wiki/Resize_splits_more_quickly Vimrc included plugins: https://github.com/amix/vimrc#included-plugins NERD Tree: https://github.com/preservim/nerdtree Vim tips using tab: https://www.linux.com/training-tutorials/vim-tips-using-tabs YouCompleteMe： https://github.com/ycm-core/YouCompleteMe coc.nvim： https://github.com/neoclide/coc.nvim/tree/release ","date":"2020-10-20","objectID":"/posts/vim-usage/:4:0","tags":null,"title":"Vim Usage","uri":"/posts/vim-usage/"},{"categories":null,"content":"背景 决定从Hexo迁移至Hugo，不再使用Hexo了。由于Hexo的官方文档缺乏维护，对我而且使用起来不方便，其次也不利于主题的开发。迁移的方法并不复杂，下面让我们开始吧。 ","date":"2020-10-19","objectID":"/posts/build-website-with-hugo/:0:1","tags":null,"title":"Hugo 构建Github Pages","uri":"/posts/build-website-with-hugo/"},{"categories":null,"content":"前置需求 我们需要， 一个your_github_user_name.github.io仓库； 一个用于保存Hugo内容的仓库（假设名字为blog）； travis ci账户，使用github账户登录并赋予其访问相关仓库的权限即可； 有条件的话，可以申请一个自己的域名。 ","date":"2020-10-19","objectID":"/posts/build-website-with-hugo/:0:2","tags":null,"title":"Hugo 构建Github Pages","uri":"/posts/build-website-with-hugo/"},{"categories":null,"content":"编写 .travis.yml 现在假设你已经将Hugo创建的文件保存至blog仓库了，为了让travis ci帮我们进行自动部署，还需要在blog仓库的根目录下放置一个.travis.yml配置文件，用于告知travis ci该如何进行操作。 .travis.yml文件的内容如下（仅限参考）， # 使用Ubuntu20.04dist:focallanguage:gogo:- 1.15# 安装Hugobefore_install:- sudoapt-getupdate- sudoapt-getinstallhugo-y--fix-missingscript:- hugo-Ddeploy:repo:your_github_user_name/your_github_user_name.github.ioprovider:pagesskip-cleanup:truegithub-token:$GH_TOKENkeep-history:true# 目前github上创建仓库后的主分支名变为了main，你需要把*.github.io的主分支名改为mastertarget_branch:masteron:branch:mainlocal-dir:public# 自定义域名，可以不添加该字段fqdn:your_domain deploy字段中各个值的含义，可以参看travis ci的官方文档[1]。 将.travis.yml文件提交至你的blog仓库中，之后我们需要在travis ci中，进行配置，为我们的blog仓库添加一个环境变量（GH_TOKEN）。 你可以在 github.com-\u003esetting-\u003eDeveloper setting-\u003ePersonal access tokens中生成一个，并设置相应权限。 ","date":"2020-10-19","objectID":"/posts/build-website-with-hugo/:0:3","tags":null,"title":"Hugo 构建Github Pages","uri":"/posts/build-website-with-hugo/"},{"categories":null,"content":"参考 Github Pages Deployment: https://docs.travis-ci.com/user/deployment/pages/ ","date":"2020-10-19","objectID":"/posts/build-website-with-hugo/:0:4","tags":null,"title":"Hugo 构建Github Pages","uri":"/posts/build-website-with-hugo/"},{"categories":null,"content":"问题 git中没有提供直接删除submodule的命令，所以当我们想要删除某个submodule时，会不知所措。 ","date":"2020-10-19","objectID":"/posts/how-to-remove-git-submodule/:0:1","tags":null,"title":"删除Git Submodule","uri":"/posts/how-to-remove-git-submodule/"},{"categories":null,"content":"方法 github上有人给出了删除submodule的方法，步骤如下： 删除.gitmodules文件中的相关内容 删除.git/config文件中的相关内容 执行git rm --cached path_to_your_submodule(不要在后面加斜杠) 执行rm -rf .git/modules/path_to_your_submodule(不要在后面加斜杠) 删除你的submodules文件，执行rm -rf path_to_your_submodule 执行git add .gitmodules并commit ","date":"2020-10-19","objectID":"/posts/how-to-remove-git-submodule/:0:2","tags":null,"title":"删除Git Submodule","uri":"/posts/how-to-remove-git-submodule/"},{"categories":null,"content":"参考 delete_git_submodule: https://gist.github.com/myusuf3/7f645819ded92bda6677 ","date":"2020-10-19","objectID":"/posts/how-to-remove-git-submodule/:0:3","tags":null,"title":"删除Git Submodule","uri":"/posts/how-to-remove-git-submodule/"},{"categories":null,"content":"ohmyzsh 插件 在安装了ohmyzsh的情况下，编辑.vimrc文件，并启用ssh-agent插件即可。插件会在开启zsh时，启动ssh-agent，并添加.ssh目录下的identifier。 ","date":"2020-10-19","objectID":"/posts/ssh-agent-startup-on-wsl/:0:1","tags":null,"title":"WSL中开启，SSh Agent自启动","uri":"/posts/ssh-agent-startup-on-wsl/"},{"categories":null,"content":"参考 ssh-agent : https://github.com/ohmyzsh/ohmyzsh/tree/master/plugins/ssh-agent ","date":"2020-10-19","objectID":"/posts/ssh-agent-startup-on-wsl/:0:2","tags":null,"title":"WSL中开启，SSh Agent自启动","uri":"/posts/ssh-agent-startup-on-wsl/"},{"categories":null,"content":"2020.10.20 开始阅读《Black Hat Go》 2020.5.11 今天买了儿时爱吃的爆米花，用火炉爆的那种，长辈笑我还是个小孩。爆米花的味道没变，但是吃爆米花的心情变了，果然还是当个小孩好啊。 2020.4.27 蜡笔小新番外篇《这就是青春》 第一集：https://www.bilibili.com/bangumi/play/ep111280 第二集：https://www.bilibili.com/bangumi/play/ep111286 第三集：https://www.bilibili.com/bangumi/play/ep111294 第四集：https://www.bilibili.com/bangumi/play/ep111302 2020.4.22 最近在修订t0data的《BurpSuite 实战指南》，还顺便学习了一下shellcode loader 2020.4.13 在Ubuntu上安装phpstudy时，发现已经安装了docker的情况下，官方给的安装脚本不给力。而且写的很糟糕，于是对其进行了重写，今天测试了一下，基本OK，明天继续进行适度修改。 2020.4.11 《第一本Docker书》看到第6章，对docker的基本使用有了大致了解。 2020.4.10 开始学习docker和shellcode。 2020.4.7 今天领会了工信部的厉害，由于域名未备案，服务器采用的又是国内的ISP，所以被卖了。只好放弃原来的方案，转用github pages。 2020.4.6 网站基本搭建完成，编写了个脚本，将hexo deploy至github的网站内容，同步至服务器。 2020.4.5 搭建网站时遇到不少问题，遂把过程记录下来。 2020.4.4 今天为抗疫纪念日，全民哀悼。 个人网站重新筹备中。 2020.4.3 偷得余生半日闲，和家人去摘了草莓，貌似来的不是时候，体验极差。 看完了《程序员的自我修养》中关于运行库的部分，这周把它看完。 ","date":"2020-04-03","objectID":"/dailies/:0:0","tags":null,"title":"Daily","uri":"/dailies/"}]